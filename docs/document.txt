REPORTS API - Complete System Overview

=== System Overview ===
Reports API is a backend service developed with Go for managing:
- Problems
- Tasks
- IP Phones
- Programs
- Departments
- Branches
- Authentication system for Users and Admins

=== Technologies Used ===
- Go 1.23.0 (Main language)
- Fiber v2 (Web framework)
- MySQL (Database)
- Docker (For containerization)
- GitLab CI/CD (For automation)

=== Project Structure ===
reports-api/
├── db/                 - Database connections
├── handlers/           - HTTP request handlers
├── middleware/         - Middleware for security and logging
├── models/            - Data structures
├── routes/            - API endpoint definitions
├── utils/             - Helper functions
├── docs/              - Documentation
├── Dockerfile         - For production
├── Dockerfile.dev     - For development
├── .gitlab-ci.yml     - CI/CD pipeline
└── main.go           - Application entry point

=== Application Workflow ===

1. Initialization:
   - Set memory limit to 384MB
   - Limit CPU cores to 2
   - Create custom logger
   - Read command line arguments (dev/prod)

2. Environment Loading:
   - Load .env.dev file for development
   - Load .env.prod file for production
   - Use environment variables if files don't exist

3. Database Connection:
   - Connect to MySQL database
   - Include error handling and connection pooling

4. Web Server Configuration:
   - Use Fiber framework
   - Configure CORS for cross-origin requests
   - Add security headers
   - Limit file upload size to 100MB
   - Set timeout to 30 seconds

5. Route Registration:
   - API routes for CRUD operations
   - Authentication routes for login/register
   - Health check endpoint (GET /)
   - Static file serving

=== Main API Endpoints ===

Authentication:
- POST /authEntry/login - User login
- POST /authEntry/registerUser - User registration
- POST /authEntry/registerAdmin - Admin registration

Problem Management:
- GET /api/v1/problem/list - List problems
- POST /api/v1/problem/create - Create new problem
- PUT /api/v1/problem/update/{id} - Update problem
- DELETE /api/v1/problem/delete/{id} - Delete problem

Task Management:
- GET /api/v1/task/list - List tasks
- POST /api/v1/task/create - Create new task
- PUT /api/v1/task/update/{id} - Update task
- DELETE /api/v1/task/delete/{id} - Delete task

Others:
- IP Phone Management: /api/v1/ipphone/*
- Program Management: /api/v1/program/*
- Department Management: /api/v1/department/*
- Branch Management: /api/v1/branch/*

=== Build and Deploy ===

1. Manual Build:
   - Development: docker build -t username/reports-api:dev -f Dockerfile.dev .
   - Production: docker build -t username/reports-api:prod -f Dockerfile .

2. Automated Build (build2.sh):
   - Interactive script for environment selection
   - Includes confirmation prompts
   - Auto Docker Hub login
   - Error handling and cleanup

3. GitLab CI/CD Pipeline:
   - Push to develop branch = auto build dev image
   - Push to main branch = manual trigger for prod image
   - Uses Docker Hub for image storage

=== Important Environment Variables ===
- PORT: Server port (default: 5001)
- DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME: Database connection
- JWT_SECRET: For JWT token
- TELEGRAM_BOT_TOKEN: For Telegram integration
- MINIO_*: For file storage

=== Docker Configuration ===

Development (Dockerfile.dev):
- Uses Go 1.23-alpine for build
- Uses alpine:latest for runtime
- Runs on port 5000
- Runs with ./main -d

Production (Dockerfile):
- Same as dev but runs on port 5001
- Runs with ./main -p
- Suitable for production environment

Docker Compose Setup:
- Multi-service orchestration with MySQL, MinIO, and Nginx
- Separate development and production configurations
- Volume management for persistent data
- Network isolation and service discovery
- Health checks and restart policies

Nginx Integration:
- Reverse proxy configuration
- SSL/TLS termination
- Load balancing support
- Rate limiting and security headers
- Static file serving
- Caching configuration

=== Security Features ===
- JWT-based authentication
- CORS configuration
- Security headers (X-Frame-Options, X-XSS-Protection, etc.)
- Input validation
- Error handling and logging
- Memory and CPU limits

=== Usage ===

1. Local Development:
   go run main.go dev

2. Docker Development:
   docker build -t reports-api-dev -f Dockerfile.dev .
   docker run -p 5001:5000 reports-api-dev

3. Health Check:
   curl http://localhost:5001/
   Response: {"status": "OK", "version": "1.0.0"}

=== Documentation ===
- README.md: Overview and quick start
- docs/API_USAGE.md: API usage guide
- docs/INSTALLATION.md: Installation guide
- docs/DEPLOYMENT.md: Deployment guide
- docs/BUILD_GUIDE.md: Docker build guide
- docs/DOCKER_SETUP.md: Comprehensive Docker configuration guide
- docs/NGINX_SETUP.md: Nginx reverse proxy and load balancer setup
- docs/PROJECT_OVERVIEW.md: Complete project overview and architecture
- swagger.yaml: API documentation
- swagger.html: Swagger UI interface

=== Common Troubleshooting ===
1. Database connection error: Check MySQL service and credentials
2. Port already in use: Change port in environment variables
3. Docker build fails: Check Dockerfile and dependencies
4. GitLab CI variables not working: Check Protected settings
5. Authentication fails: Check JWT_SECRET and token expiry

=== Performance Optimization ===
- Memory limit: 384MB
- CPU limit: 2 cores
- Garbage collection: 50%
- Connection timeout: 30 seconds
- File upload limit: 100MB
- Request/response compression

This system is designed to support real-world usage with good scalability, security, and maintainability

=== Infrastructure and Deployment ===

Container Orchestration:
- Docker containerization for all services
- Docker Compose for multi-service deployment
- Kubernetes-ready configuration
- Health checks and auto-restart capabilities

Reverse Proxy and Load Balancing:
- Nginx as reverse proxy
- SSL/TLS termination
- HTTP/2 support
- Rate limiting and DDoS protection
- Static file serving optimization
- Caching strategies for improved performance

Database Management:
- MySQL 8.0 with connection pooling
- Automated backup strategies
- Volume persistence in containers
- Migration and schema management

File Storage:
- MinIO object storage integration
- Scalable file upload handling
- Image processing and optimization
- Secure file access with presigned URLs

Monitoring and Logging:
- Comprehensive access and error logging
- Performance metrics collection
- Health check endpoints
- Real-time monitoring capabilities

Security Implementation:
- JWT-based authentication
- CORS configuration
- Security headers implementation
- Input validation and sanitization
- Rate limiting and IP filtering
- SSL/TLS encryption